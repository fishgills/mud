name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_version:
        description: 'Optional image tag override'
        required: false

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: ${{ secrets.GCP_REGION }}
  REGISTRY_NAME: mud-registry
  TF_IN_AUTOMATION: true
  CLOUD_SQL_CONNECTION_NAME: ${{ secrets.CLOUD_SQL_CONNECTION_NAME }}
  GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
  GCP_SERVICE_ACCOUNT: ${{ secrets.GCP_SERVICE_ACCOUNT }}
  TF_BACKEND_BUCKET: ${{ secrets.TF_BACKEND_BUCKET }}
  TF_BACKEND_PREFIX: ${{ secrets.TF_BACKEND_PREFIX }}

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    outputs:
      build_version: ${{ steps.version.outputs.build_version }}
      services: ${{ steps.affected.outputs.services_csv }}
      services_json: ${{ steps.affected.outputs.services_json }}
      services_matrix: ${{ steps.affected.outputs.services_matrix }}
      has_service_changes: ${{ steps.affected.outputs.has_service_changes }}
      infra_changed: ${{ steps.affected.outputs.infra_changed }}
      should_deploy: ${{ steps.affected.outputs.should_deploy }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine build version
        id: version
        run: |
          set -eo pipefail
          VERSION_INPUT="${{ inputs.build_version }}"
          if [ -n "$VERSION_INPUT" ]; then
            VERSION="$VERSION_INPUT"
          else
            if git rev-parse --short HEAD >/tmp/short_sha 2>/dev/null; then
              VERSION=$(cat /tmp/short_sha)
            else
              VERSION=$(date -u +"%Y%m%d%H%M%S")
            fi
          fi
          echo "Using build version: $VERSION"
          echo "BUILD_VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "build_version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Determine affected deployment scope
        id: affected
        env:
          EVENT_NAME: ${{ github.event_name }}
          BEFORE_SHA: ${{ github.event.before }}
        run: |
          set -Eeuo pipefail
          ALL_SERVICES=(dm world slack-bot tick)
          FORCE_ALL=0
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            FORCE_ALL=1
          fi

          BASE_SHA="$BEFORE_SHA"
          HEAD_SHA="${GITHUB_SHA}"
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ]; then
            if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              BASE_SHA=$(git rev-parse HEAD^)
            else
              BASE_SHA=$HEAD_SHA
            fi
          fi
          echo "Comparing changes between $BASE_SHA and $HEAD_SHA"

          INFRA_CHANGED=0
          if git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep '^infra/terraform/' >/dev/null; then
            INFRA_CHANGED=1
            echo "Detected infrastructure changes under infra/terraform/."
          fi

          SERVICES=()
          declare -A seen=()

          if [ $FORCE_ALL -eq 1 ]; then
            echo "workflow_dispatch event detected; deploying all services."
            SERVICES=("${ALL_SERVICES[@]}")
          else
            NX_OUTPUT_FILE=$(mktemp)
            if npx nx print-affected --type=app --select=projects --base="$BASE_SHA" --head="$HEAD_SHA" >"$NX_OUTPUT_FILE"; then
              while IFS= read -r project; do
                [ -n "$project" ] || continue
                mapped=""
                case "$project" in
                  "@mud/dm"|"dm") mapped="dm" ;;
                  "@mud/world"|"world") mapped="world" ;;
                  "@mud/slack-bot"|"slack-bot") mapped="slack-bot" ;;
                  "@mud/tick"|"tick") mapped="tick" ;;
                esac
                if [ -n "$mapped" ] && [ -z "${seen[$mapped]:-}" ]; then
                  SERVICES+=("$mapped")
                  seen[$mapped]=1
                fi
              done <"$NX_OUTPUT_FILE"
            else
              echo "nx print-affected failed; defaulting to all services."
              SERVICES=("${ALL_SERVICES[@]}")
            fi
            rm -f "$NX_OUTPUT_FILE"
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            IFS=$'\n' SERVICES=($(printf '%s\n' "${SERVICES[@]}" | sort))
          fi

          SERVICES_JSON="[]"
          SERVICES_MATRIX='[{"service":"__noop__","skip":true}]'
          if [ ${#SERVICES[@]} -gt 0 ]; then
            json_items=()
            matrix_items=()
            for svc in "${SERVICES[@]}"; do
              json_items+=("\"${svc}\"")
              matrix_items+=("{\"service\":\"${svc}\",\"skip\":false}")
            done
            SERVICES_JSON="[$(IFS=,; echo "${json_items[*]}")]"
            SERVICES_MATRIX="[$(IFS=,; echo "${matrix_items[*]}")]"
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            HAS_SERVICE_CHANGES=true
            echo "Affected services: ${SERVICES[*]}"
          else
            HAS_SERVICE_CHANGES=false
            echo "No Nx-affected services detected."
          fi

          if [ $INFRA_CHANGED -eq 1 ]; then
            echo "Infrastructure changes detected."
          fi

          if [ "$HAS_SERVICE_CHANGES" = "true" ] || [ $INFRA_CHANGED -eq 1 ] || [ $FORCE_ALL -eq 1 ]; then
            SHOULD_DEPLOY=true
          else
            SHOULD_DEPLOY=false
          fi

          if [ "$SHOULD_DEPLOY" = "false" ]; then
            echo "No deployable changes detected; subsequent deployment steps will be skipped."
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            SERVICES_CSV=$(IFS=,; echo "${SERVICES[*]}")
          else
            SERVICES_CSV=""
          fi

          {
            echo "services_csv=$SERVICES_CSV"
            echo "services_json=$SERVICES_JSON"
            echo "services_matrix=$SERVICES_MATRIX"
            echo "has_service_changes=$HAS_SERVICE_CHANGES"
            echo "infra_changed=$([ $INFRA_CHANGED -eq 1 ] && echo true || echo false)"
            echo "should_deploy=$SHOULD_DEPLOY"
          } >>"$GITHUB_OUTPUT"

      - name: Ensure Workload Identity secrets are configured
        if: steps.affected.outputs.has_service_changes == 'true'
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        if: steps.affected.outputs.has_service_changes == 'true'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        if: steps.affected.outputs.has_service_changes == 'true'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        if: steps.affected.outputs.has_service_changes == 'true'
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Configure Docker authentication
        if: steps.affected.outputs.has_service_changes == 'true'
        run: gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

      - name: Sync Nx workspace
        if: steps.affected.outputs.has_service_changes == 'true'
        run: npx nx sync

  build-service:
    name: Build and Push Service (${{ matrix.service }})
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.build-and-push.outputs.services_matrix) }}
    env:
      BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Skip noop matrix entry
        if: ${{ matrix.skip == true }}
        run: echo "No services to build for this matrix entry."

      - name: Authenticate to Google Cloud
        if: ${{ matrix.skip != true }}
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        if: ${{ matrix.skip != true }}
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        if: ${{ matrix.skip != true }}
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Configure Docker authentication
        if: ${{ matrix.skip != true }}
        run: gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

      - name: Build and push service image
        if: ${{ matrix.skip != true }}
        env:
          SERVICE_NAME: ${{ matrix.service }}
        run: |
          set -Eeuo pipefail
          REGISTRY_URL="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REGISTRY_NAME}"
          IMAGE_TAG="${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_VERSION}"
          IMAGE_LATEST="${REGISTRY_URL}/${SERVICE_NAME}:latest"
          DOCKERFILE="apps/${SERVICE_NAME}/Dockerfile"
          echo "Building image for ${SERVICE_NAME}..."
          docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" -f "$DOCKERFILE" .
          echo "Pushing ${SERVICE_NAME} images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"

  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs:
      - build-and-push
      - build-service
    if: needs.build-and-push.outputs.should_deploy == 'true'
    environment: production
    permissions:
      contents: read
      id-token: write
    env:
      BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure Workload Identity secrets are configured
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Prepare Terraform plugin cache directory
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Cache Terraform plugin directory
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-terraform-${{ hashFiles('infra/terraform/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Ensure terraform.tfvars exists
        run: |
          if [ ! -f infra/terraform/terraform.tfvars ]; then
            cp infra/terraform/terraform.tfvars.example infra/terraform/terraform.tfvars
            terraform fmt -recursive infra/terraform/terraform.tfvars
          fi

      - name: Fetch database password secret
        id: db-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Inject database password into Terraform vars
        env:
          DB_PASSWORD: ${{ steps.db-secret.outputs.db_password }}
        run: |
          set -Eeuo pipefail
          echo "::add-mask::${DB_PASSWORD}"
          TFVARS="infra/terraform/terraform.tfvars"
          TMP_FILE="$(mktemp)"
          if [ -f "$TFVARS" ]; then
            grep -v '^[[:space:]]*db_password[[:space:]]*=' "$TFVARS" > "$TMP_FILE"
          fi
          printf 'db_password = "%s"\n' "$DB_PASSWORD" >> "$TMP_FILE"
          install -m 0644 "$TMP_FILE" "$TFVARS"
          rm -f "$TMP_FILE"

      - name: Prepare service image overrides
        env:
          BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
          SERVICES_CSV: ${{ needs.build-and-push.outputs.services }}
        run: |
          set -Eeuo pipefail
          REGISTRY_URL="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REGISTRY_NAME}"
          declare -A changed=()
          if [ -n "$SERVICES_CSV" ]; then
            IFS=',' read -ra CHANGED <<< "$SERVICES_CSV"
            for svc in "${CHANGED[@]}"; do
              [ -n "$svc" ] || continue
              changed[$svc]=1
            done
          fi

          SERVICES=(dm world slack-bot tick)
          TF_FILE="infra/terraform/service-overrides.auto.tfvars"
          {
            echo "service_image_overrides = {"
            for svc in "${SERVICES[@]}"; do
              if [ -n "${changed[$svc]:-}" ]; then
                image="${REGISTRY_URL}/${svc}:${BUILD_VERSION}"
              else
                image=$(gcloud run services describe "mud-${svc}" --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(template.containers[0].image)" || true)
                if [ -z "$image" ]; then
                  image="${REGISTRY_URL}/${svc}:latest"
                fi
              fi
              echo "  \"${svc}\" = \"${image}\""
            done
            echo "}"
          } > "$TF_FILE"
          terraform -chdir=infra/terraform fmt "$(basename "$TF_FILE")"
          echo "Pinned service images written to $TF_FILE"

      - name: Write Terraform backend config
        env:
          TF_BACKEND_BUCKET: ${{ env.TF_BACKEND_BUCKET }}
          TF_BACKEND_PREFIX: ${{ env.TF_BACKEND_PREFIX }}
        run: |
          set -Eeuo pipefail
          if [ -z "$TF_BACKEND_BUCKET" ] || [ -z "$TF_BACKEND_PREFIX" ]; then
            echo "Missing TF_BACKEND_BUCKET or TF_BACKEND_PREFIX secrets."
            exit 1
          fi
          printf 'bucket = "%s"\n' "$TF_BACKEND_BUCKET" > infra/terraform/backend.hcl
          printf 'prefix = "%s"\n' "$TF_BACKEND_PREFIX" >> infra/terraform/backend.hcl
          echo "Terraform backend config written to infra/terraform/backend.hcl"

      - name: Terraform fmt check
        working-directory: infra/terraform
        run: terraform fmt -check -recursive

      - name: Terraform init
        working-directory: infra/terraform
        run: terraform init -input=false -backend-config=backend.hcl

      - name: Terraform validate
        working-directory: infra/terraform
        run: terraform validate

      - name: Terraform plan
        working-directory: infra/terraform
        run: |
          terraform plan \
            -input=false \
            -var=project_id="$GCP_PROJECT_ID" \
            -var=region="$GCP_REGION" \
            -var=image_version="$BUILD_VERSION" \
            -out=tfplan

      - name: Terraform apply
        working-directory: infra/terraform
        run: |
          terraform apply \
            -input=false \
            -auto-approve \
            tfplan

      - name: Clean up Terraform plan
        if: always()
        working-directory: infra/terraform
        run: rm -f tfplan

      - name: Clean up service image overrides
        if: always()
        run: rm -f infra/terraform/service-overrides.auto.tfvars

      - name: Update service endpoints
        run: |
          set -Eeuo pipefail
          DM_URL=$(gcloud run services describe mud-dm --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(status.url)")
          WORLD_URL=$(gcloud run services describe mud-world --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(status.url)")
          if [ -z "$DM_URL" ] || [ -z "$WORLD_URL" ]; then
            echo "Could not retrieve dm/world service URLs. Skipping endpoint update."
            exit 0
          fi
          DM_GQL="${DM_URL}/graphql"
          WORLD_GQL="${WORLD_URL}/graphql"
          WORLD_BASE="${WORLD_URL}/world"
          echo "Resolved endpoints:"
          echo "  DM_GQL_ENDPOINT=$DM_GQL"
          echo "  WORLD_GQL_ENDPOINT=$WORLD_GQL"
          echo "  WORLD_BASE_URL=$WORLD_BASE"
          gcloud run services update mud-slack-bot \
            --region="$GCP_REGION" \
            --project="$GCP_PROJECT_ID" \
            --update-env-vars="DM_GQL_ENDPOINT=${DM_GQL},WORLD_GQL_ENDPOINT=${WORLD_GQL}"
          gcloud run services update mud-tick \
            --region="$GCP_REGION" \
            --project="$GCP_PROJECT_ID" \
            --update-env-vars="DM_GRAPHQL_URL=${DM_GQL}"

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs:
      - deploy-infra
    environment: production
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Ensure Workload Identity secrets are configured
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Fetch database password secret
        id: migration-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Run Prisma migrations
        env:
          DB_PASSWORD: ${{ steps.migration-secret.outputs.db_password }}
        run: |
          set -Eeuo pipefail
          echo "::add-mask::${DB_PASSWORD}"
          CONNECTION_NAME="${CLOUD_SQL_CONNECTION_NAME:-battleforge-444008:us-central1:mud-postgres}"
          PROXY_PATH="scripts/cloud-sql-proxy"
          if [ ! -f "$PROXY_PATH" ]; then
            curl -sSL -o "$PROXY_PATH" "https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.18.1/cloud-sql-proxy.linux.amd64"
            chmod +x "$PROXY_PATH"
          fi
          "$PROXY_PATH" --address=127.0.0.1 --port=5432 "$CONNECTION_NAME" &
          PROXY_PID=$!
          cleanup() {
            if kill -0 "$PROXY_PID" 2>/dev/null; then
              kill "$PROXY_PID"
              wait "$PROXY_PID" || true
            fi
          }
          trap cleanup EXIT
          sleep 5
          export DATABASE_URL="postgresql://mud:${DB_PASSWORD}@127.0.0.1:5432/mud_dev?schema=public&sslmode=disable&connect_timeout=60"
          npx prisma migrate deploy --schema=libs/database/prisma/schema.prisma
