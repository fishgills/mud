# BattleForge Item Progression + Global Shop (Tiered Tickets) — Agent Spec

This document defines:

1. Infinite-scaling **item progression** (power, stats, weapon dice)
2. A global, shared **shop refresh** mechanic where everyone sees the same inventory
3. A **tiered ticket** system that gates high-tier purchases (Option 1)

All formulas are written in code blocks to avoid markdown/math rendering issues.

---

## 0) Design Goals

- Infinite progression (no hard level cap)
- Items modify **base stats** (intuitive for non-RPG players)
- Weapons also have **damage dice** (e.g., 2d10) as a meaningful reward
- Global rotating shop with scarcity and competition
- High-tier items remain rare **without probabilities going to ~0 forever**
- Tickets act as a soft gate + gold sink and integrate with raid depth

---

## 1) Slots

Slots:

- head
- chest
- legs
- arms
- weapon

Recommended slot weights (power budget multipliers):

```text
slotWeight:
  weapon = 1.00
  chest  = 0.85
  legs   = 0.65
  arms   = 0.55
  head   = 0.45
```

Optional slot price multipliers:

```text
slotPriceMultiplier:
  weapon = 1.30
  chest  = 1.10
  legs   = 1.00
  arms   = 0.90
  head   = 0.85
```

---

## 2) Item Power (IP) — Infinite Scaling

Items are generated by **tier**. Tier is an integer analogous to level-banding.

Base power at tier `L`:

```text
IP_base(L) = floor(10 * sqrt(L))
```

Slot-adjusted power:

```text
IP_item(L, slot) = round(IP_base(L) * slotWeight[slot])
```

Notes:

- This grows forever and stays tame because `sqrt(L)` grows slowly.
- Item power drives stat bonuses and (for weapons) damage dice tier.

---

## 3) Stat Bonuses (S/A/H) from IP

Items modify base stats by allocating a **stat budget** derived from `IP_item`.

Define archetypes (weights sum to 1):

```text
Offense:  wS=0.70, wA=0.30, wH=0.00
Evasion:  wS=0.00, wA=0.70, wH=0.30
Tank:     wS=0.00, wA=0.30, wH=0.70
Balanced: wS=0.40, wA=0.30, wH=0.30
```

Compute bonuses:

```text
statBudget = IP_item
S_bonus = floor(statBudget * wS)
A_bonus = floor(statBudget * wA)
H_bonus = statBudget - S_bonus - A_bonus
```

Store/display these as simple integers: `+12 Strength`, `+8 Agility`, etc.

---

## 4) Weapons: Damage Dice + Stat Bonuses

Weapons should remain exciting via damage dice. Weapons also get S/A bonuses.

### 4.1 Weapon dice tier ladder

Define tiers by minimum item tier `L`:

```text
Tier -> Min L -> Dice
1    -> 1     -> 1d4
2    -> 3     -> 1d6
3    -> 6     -> 1d8
4    -> 10    -> 1d10
5    -> 15    -> 1d12
6    -> 22    -> 2d6
7    -> 30    -> 2d8
8    -> 40    -> 2d10
9    -> 55    -> 3d8
10   -> 75    -> 3d10
11   -> 100   -> 4d10
```

Extension beyond tier 11:

- Increase dice count slowly (every ~25–50 tiers)
- Prefer increasing sides up to d12 before increasing count again

### 4.2 Mapping tier L to a dice spec

Agent implementation can:

- Use the above lookup table (recommended)
- Or compute via a function (optional)

### 4.3 Weapon damage integration (combat)

Weapon dice are the base roll:

```text
W_roll = sum_{i=1..n} uniformInt(1..m)   // NdM weapon
```

Use in final damage:

```text
D_base = W_roll + floor(1.2*S_eff + 0.3*L_eff)
damage = max(1, D_base * (1 - mitigation))
```

(See combat spec for `S_eff`, `L_eff`, and `mitigation`.)

---

## 5) Item Pricing (Power-based, Infinite)

Price grows superlinearly with item power.

Base price:

```text
priceBase(IP) = round(c * IP^p)
```

Recommended constants:

```text
c = 2
p = 1.6
```

Final price:

```text
price(IP, slot) = round(priceBase(IP) * slotPriceMultiplier[slot])
```

Rationale:

- Superlinear growth ensures meaningful gold sinks at high tiers.
- Slot multipliers keep weapons and chest pieces appropriately expensive.

---

## 6) Global Shop Refresh (Shared Inventory)

All players see the **same inventory** each refresh period.

### 6.1 Refresh schedule

Choose one:

- Every N minutes (recommended, e.g., 5–15 minutes)
- Every game tick (if tick is not too frequent)

### 6.2 Define global shop tier `T`

Let `medianLevel` be the median player level across active players (or recently active players).

Simple default:

```text
T = floor(medianLevel)
```

If you want shop to lag slightly behind whales:

```text
T = floor(medianLevel^0.8)
```

### 6.3 Tier offsets (bounded)

Instead of sampling from infinite tiers, sample a bounded offset `k`:

```text
k ∈ {-3, -2, -1, 0, +1, +2, +3, +4}
itemTier = T + k
itemTier = max(1, itemTier)
```

### 6.4 Offset weights (never zero)

Use geometric weights:

```text
a = 0.45  // higher tier decay
b = 0.80  // lower tier bias

weight(k) = a^k    for k >= 0
weight(k) = b^(-k) for k < 0
```

Normalize weights across k to get probabilities.

### 6.5 Stock counts (scarcity increases with tier)

Given `baseStock = 6` and `c_stock = 1.6`:

```text
stock(k) = max(1, round(baseStock * (c_stock^(-k))))
```

### 6.6 Shop layout (suggested)

Example per refresh (10 listings):

- 2 weapons
- 2 chest
- 2 legs
- 2 arms
- 2 head

Each listing generation:

1. sample offset `k` using weights
2. tier = T + k
3. slot = predetermined by layout
4. IP = IP_item(tier, slot)
5. stat bonuses from IP and archetype
6. weapon dice (weapon only)
7. price from IP and slot
8. stock from `stock(k)`

---

## 7) Tiered Tickets (Option 1)

Tickets gate high-tier purchases while keeping early shop friction low.

### 7.1 Ticket tiers

```text
Ticket tiers:
- Rare Ticket
- Epic Ticket
- Legendary Ticket
```

### 7.2 Ticket requirement by offset

Recommended minimal friction:

- No ticket required for k <= +1
- Epic Ticket required for k == +2
- Legendary Ticket required for k >= +3

```text
requiresTicket(k):
  if k <= +1: none
  if k == +2: Epic
  if k >= +3: Legendary
```

### 7.3 Ticket earning via raids

When a raid ends with **Finish** at depth `D`, grant a ticket chance.

Chance curves (clamped):

```text
p_rare = clamp(0.10 + 0.02*D, 0.10, 0.60)
p_epic = clamp(0.02 + 0.01*D, 0.02, 0.25)
p_leg  = clamp(0.005 + 0.002*D, 0.005, 0.05)
```

Roll order (highest first):

1. if rand < p_leg: Legendary
2. else if rand < p_epic: Epic
3. else if rand < p_rare: Rare
4. else none

### 7.4 Ticket purchase pricing (optional)

Tickets may also be purchasable with gold.

Let `T` be current global shop tier:

```text
ticketPriceRare = round(  50 * sqrt(T) )
ticketPriceEpic = round( 200 * sqrt(T) )
ticketPriceLeg  = round( 800 * sqrt(T) )
```

(Use `T^0.75` instead of `sqrt(T)` if you need steeper scaling.)

---

## 8) Chase Item Guarantee (Pity Timer)

Define chase items as `k = +4` (or the max offset in your range).

If no chase item appears in `R` refreshes, force one next refresh.

```text
R = 20
```

Implementation:

- Track `refreshesSinceChase`
- If `refreshesSinceChase >= R`, set one listing’s k to max offset and reset counter

---

## 9) Purchase Rules (First-Come-First-Buy)

When a player attempts to buy:

- Validate listing still has stock > 0
- Validate player has enough gold
- Validate ticket requirement (based on listing offset k)
- If OK:
  - decrement stock (global)
  - decrement gold
  - decrement ticket if required
  - grant item to player inventory

Important:

- Stock must be decremented atomically (transaction/lock).

---

## 10) Suggested Data Model (Minimal)

```text
ShopListing:
  listingId
  refreshId
  slot
  tier
  offsetK
  ip
  sBonus
  aBonus
  hBonus
  weaponDiceCount (nullable)
  weaponDiceSides (nullable)
  priceGold
  stockRemaining

PlayerTickets:
  rareCount
  epicCount
  legendaryCount
```

---

## 11) Tunables (Design Knobs)

```text
Item power:
  IP_base coefficient (10)
  slotWeight

Shop:
  offset set [-3..+4]
  a (0.45), b (0.80)
  baseStock (6), c_stock (1.6)
  refresh cadence
  global tier T definition
  pity timer R (20)

Tickets:
  offset -> ticket mapping
  raid ticket chance curves
  ticket gold prices
```

---

## 12) Implementation Checklist

- [ ] Implement IP_base and slot weights
- [ ] Generate stat bonuses from archetypes
- [ ] Add weapon dice tier ladder + mapping
- [ ] Implement price formula
- [ ] Implement global shop tier calculation (medianLevel)
- [ ] Implement bounded offset sampling + weights
- [ ] Implement stock scaling and refresh generation
- [ ] Implement ticket requirements and purchase validation
- [ ] Implement raid reward ticket rolls
- [ ] Add chase pity timer guarantee
- [ ] Ensure purchase decrements stock atomically
