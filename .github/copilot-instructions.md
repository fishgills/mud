# GitHub Copilot Instructions for Mud

## Project Overview

Mud is an AI-assisted multiplayer text adventure game built as a Turborepo monorepo. It features procedurally generated worlds, turn-based gameplay, and a Slack bot interface for player interaction.

### Architecture

- **Backend**: NestJS services communicating via GraphQL
- **Database**: PostgreSQL with Prisma ORM
- **Cache**: Redis for world rendering and coordination
- **Frontend**: Slack Bolt app for player interactions
- **Infrastructure**: Google Cloud Platform (Cloud Run) with Terraform
- **AI Integration**: OpenAI API for dynamic descriptions and content

## Technology Stack

### Core Technologies

- **TypeScript** - Primary language across all services
- **Turborepo** - Monorepo management with task orchestration
- **NestJS** - Framework for `dm` and `world` services
- **GraphQL** - API layer with Apollo Server
- **Prisma** - Database ORM and migrations
- **Redis** - Caching layer
- **Jest** - Testing framework with SWC transform
- **Slack Bolt** - Bot framework

### Build & Dev Tools

- **@swc/jest** - Fast Jest transformations
- **@graphql-codegen/cli** - TypeScript type generation from GraphQL schemas
- **ESLint** - Code linting
- **Prettier** - Code formatting
- **Docker** - Local development and deployment
- **Terraform** - Infrastructure as code

## Monorepo Structure

```
mud/
├── apps/
│   ├── dm/              # Dungeon Master service (game logic, AI descriptions)
│   ├── world/           # World generation and rendering service
│   ├── slack-bot/       # Slack bot for player commands
│   └── tick/            # Worker for advancing game state
├── libs/
│   ├── database/        # Shared Prisma schema and client
│   ├── gcp-auth/        # GCP authentication utilities
│   ├── redis-client/    # Redis client wrapper
│   └── constants/       # Shared constants
├── infra/
│   └── terraform/       # GCP infrastructure definitions
└── scripts/             # Deployment and operational scripts
```

## Coding Standards

### TypeScript

- Use strict TypeScript configuration
- Prefer explicit types over `any`
- Use interfaces for object shapes, types for unions/intersections
- Enable strict null checks
- Use `readonly` for immutable properties

### Testing

- **Coverage Requirements**:
  - Branch coverage: Target 80%+ for all apps
  - Statement coverage: Target 80%+
  - Lines coverage: Target 80%+
  - Functions coverage: Target 80%+

- **Test Structure**:
  - Use descriptive test names with `describe` blocks
  - Test happy paths AND edge cases
  - Mock external dependencies (database, Redis, HTTP calls)
  - Mock environment variables using `jest.mock()` at top of test files
  - Clean up resources in `afterEach`/`afterAll`

- **Example Mock Pattern**:
  ```typescript
  jest.mock('../env', () => ({
    OPENAI_API_KEY: 'test-key',
    DATABASE_URL: 'postgresql://test',
  }));
  ```

### NestJS Services

- Use dependency injection for all services
- Implement proper error handling with NestJS exceptions
- Use DTOs for input validation
- Add GraphQL decorators for schema generation
- Use interceptors for cross-cutting concerns (logging, caching)

### GraphQL

- Define schemas in `.gql` files at the root level
- Run `yarn turbo codegen` after schema changes
- Use typed GraphQL request clients generated by codegen
- Document queries and mutations with descriptions

### Database (Prisma)

- **Schema Location**: `libs/database/prisma/schema.prisma`
- Run `npx prisma migrate dev` for local schema changes
- Run `npx prisma migrate deploy` for production deployments
- Always generate types after migrations: `npx prisma generate`
- Use transactions for multi-step operations
- Index frequently queried fields

### Environment Variables

- Use `envalid` for environment variable validation
- Define env schemas in dedicated `env.ts` files per app
- **Never** call `process.exit()` in environment validation during tests
- Mock environment in tests to prevent initialization issues

## Common Tasks

### Running Tests

```bash
# Run all tests
yarn test

# Run tests for specific app
yarn turbo run test --filter=@mud/dm
yarn turbo run test --filter=@mud/slack-bot
yarn turbo run test --filter=@mud/world

# Run with coverage
yarn turbo run test -- --coverage
```

### GraphQL Code Generation

```bash
# Generate all TypeScript types from GraphQL schemas
yarn turbo codegen

# Path resolution (IMPORTANT):
# - Codegen runs from each app directory
# - Schema paths use '../../' to reference root-level schemas
# - Output paths are relative to app directory (e.g., 'src/generated/')
```

### Database Operations

```bash
# Apply migrations (development)
yarn db:migrate:dev

# Apply migrations (production)
yarn db:migrate:deploy

# Push schema changes without migrations
yarn db:push

# Seed database
yarn db:seed
```

### Development Servers

```bash
# Start all services
yarn serve

# Start specific service
yarn turbo run serve --filter=@mud/dm
yarn turbo run serve --filter=@mud/world
yarn turbo run serve --filter=@mud/slack-bot
```

### Building

```bash
# Build all apps
yarn build

# Build specific app
yarn turbo run build --filter=@mud/dm
```

## Critical Implementation Patterns

### Error Handling

- Use NestJS built-in exceptions (`BadRequestException`, `NotFoundException`, etc.)
- Log errors with context using logging interceptors
- Return GraphQL errors with proper error codes
- Handle Redis connection errors gracefully with retries

### Caching Strategy

- Use Redis for:
  - World rendering cache (tiles, maps)
  - Coordination locks (turn-based gameplay)
  - Tile description cache
- Set appropriate TTLs based on environment variables
- Implement cache warming for frequently accessed data

### AI Integration (DM Service)

- Use OpenAI API for dynamic content generation
- Implement retry logic with exponential backoff
- Cache AI-generated descriptions in Redis
- Use coordination locks to prevent duplicate generations
- Handle rate limits gracefully

### Service Communication

- Use GraphQL for service-to-service calls
- Implement GCP Cloud Run authentication using `@mud/gcp-auth`
- Handle network errors with retries and circuit breakers
- Log all external service calls

## File Organization

### Test Files

- Co-locate tests with source: `*.spec.ts` next to `*.ts`
- Use `jest.config.js` in each app directory
- Extend base config from root `jest.base.config.cjs`

### GraphQL Files

- Schemas: Root level (e.g., `dm-schema.gql`, `world-schema.gql`)
- Operations: `apps/{app}/src/graphql/*.graphql`
- Generated types: `apps/{app}/src/generated/`

### Configuration Files

- TypeScript config: Per-app `tsconfig.json` extending root config
- ESLint: Per-app `eslint.config.mjs`
- NestJS: `nest-cli.json` in NestJS apps

## Known Issues & Solutions

### Issue: GraphQL Codegen Path Errors

**Problem**: `Unable to find any GraphQL type definitions`

**Solution**:

- Schema paths must be relative to app directory: `../../dm-schema.gql`
- Output paths must be relative to app directory: `src/generated/`
- Install missing plugin: `@graphql-codegen/typescript-graphql-request`

### Issue: GitHub Actions Test Failures

**Problem**: Tests fail in CI with `process.exit called with 1` from envalid

**Solution**: Mock environment variables in test setup:

```typescript
jest.mock('../env', () => ({
  // Provide all required env vars
}));
```

### Issue: Jest Hanging on Open Handles

**Solution**:

- Set `testTimeout: 10000` in jest config
- Clean up database connections in `afterAll`
- Close Redis connections after tests

## Docker & Deployment

### Local Development

- Use `docker-compose.yml` for PostgreSQL and Redis
- Each app has a `Dockerfile` for containerization
- Use `.env.local` files for local configuration

### Cloud Deployment

- Terraform modules in `infra/terraform/`
- Deploy with `scripts/deploy.py`
- Services run on Google Cloud Run
- Secrets managed via GCP Secret Manager

## Documentation

### Per-App Documentation

- `apps/dm/SETUP.md` - DM service setup
- `apps/dm/GAME_FLOW.md` - Game mechanics
- `apps/world/TILE_OPERATIONS.md` - Tile system

### Root Documentation

- `README.md` - Project overview and quickstart
- `CODEGEN_FIX.md` - GraphQL codegen troubleshooting
- `BRANCH_COVERAGE_IMPROVEMENTS.md` - Test coverage improvements
- `TEST_COVERAGE_IMPROVEMENTS.md` - Testing guidelines

## Best Practices for AI Assistance

When working with Copilot on this project:

1. **Context First**: Always check existing patterns in similar files
2. **Test Coverage**: Add tests for edge cases and error paths when implementing features
3. **Type Safety**: Leverage generated GraphQL types instead of `any`
4. **Environment**: Mock environment variables in tests to avoid initialization issues
5. **Paths**: Remember that Turbo runs commands from app directories, not root
6. **Caching**: Consider Redis cache invalidation when modifying data
7. **AI Costs**: Cache AI-generated content to minimize OpenAI API calls
8. **Monorepo**: Use `--filter` flag with Turbo commands to target specific apps
9. **Migrations**: Always run `prisma migrate` before `prisma generate`
10. **Service URLs**: Ensure service endpoints are correctly configured with `/graphql` paths

## Commands Reference

| Command                  | Description                                    |
| ------------------------ | ---------------------------------------------- |
| `yarn turbo codegen`     | Generate TypeScript types from GraphQL schemas |
| `yarn build`             | Build all apps                                 |
| `yarn test`              | Run all tests                                  |
| `yarn lint`              | Lint all code                                  |
| `yarn format`            | Format code with Prettier                      |
| `yarn serve`             | Start all development servers                  |
| `yarn db:migrate:dev`    | Run Prisma migrations (dev)                    |
| `yarn db:migrate:deploy` | Run Prisma migrations (prod)                   |
| `yarn db:push`           | Push schema changes without migrations         |
| `npx prisma studio`      | Open Prisma Studio GUI                         |

## Getting Help

- Check app-specific READMEs in `apps/{app}/`
- Review test files for implementation examples
- Check generated GraphQL types in `apps/{app}/src/generated/`
- Review Prisma schema in `libs/database/prisma/schema.prisma`
