name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_version:
        description: 'Optional image tag override'
        required: false
      force_all_services:
        description: 'Force deploy all services (true/false)'
        required: false
        default: 'false'

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: ${{ secrets.GCP_REGION }}
  REGISTRY_NAME: mud-registry
  TF_IN_AUTOMATION: true
  CLOUD_SQL_CONNECTION_NAME: ${{ secrets.CLOUD_SQL_CONNECTION_NAME }}
  GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
  GCP_SERVICE_ACCOUNT: ${{ secrets.GCP_SERVICE_ACCOUNT }}
  TF_BACKEND_BUCKET: ${{ secrets.TF_BACKEND_BUCKET }}
  TF_BACKEND_PREFIX: ${{ secrets.TF_BACKEND_PREFIX }}

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  detect-changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      build_version: ${{ steps.version.outputs.build_version }}
      affected_services: ${{ steps.affected.outputs.services }}
      has_infra_changes: ${{ steps.affected.outputs.has_infra_changes }}
      has_db_changes: ${{ steps.affected.outputs.has_db_changes }}
      should_deploy: ${{ steps.affected.outputs.should_deploy }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine build version
        id: version
        run: |
          VERSION_INPUT="${{ inputs.build_version }}"
          if [ -n "$VERSION_INPUT" ]; then
            VERSION="$VERSION_INPUT"
          else
            VERSION=$(git rev-parse --short HEAD)
          fi
          echo "build_version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Using build version: $VERSION"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Detect affected services and changes
        id: affected
        run: |
          set -e
          
          # Check for force deploy flag
          FORCE_ALL="${{ inputs.force_all_services }}"
          if [ "$FORCE_ALL" = "true" ]; then
            echo "Force deploy requested - deploying all services"
            AFFECTED_SERVICES='["dm","world","slack-bot","tick"]'
            HAS_INFRA_CHANGES=true
            HAS_DB_CHANGES=true
            SHOULD_DEPLOY=true
          else
            # Detect infrastructure changes
            if git diff --name-only HEAD~1 HEAD | grep -q '^infra/terraform/'; then
              HAS_INFRA_CHANGES=true
              echo "Infrastructure changes detected"
            else
              HAS_INFRA_CHANGES=false
            fi
            
            # Detect database schema changes
            if git diff --name-only HEAD~1 HEAD | grep -q '^libs/database/prisma/schema.prisma'; then
              HAS_DB_CHANGES=true
              echo "Database schema changes detected"
            else
              HAS_DB_CHANGES=false
            fi
            
            # Use Turborepo to detect affected services
            # Note: We check which services have changes that would affect their build
            AFFECTED=()
            for service in dm world slack-bot tick; do
              # Check if this service or its dependencies have changes
              if yarn turbo run build --filter="@mud/${service}...[HEAD~1]" --dry=json 2>/dev/null | jq -e '.tasks | length > 0' >/dev/null; then
                AFFECTED+=("\"$service\"")
                echo "Service affected: $service"
              fi
            done
            
            if [ ${#AFFECTED[@]} -gt 0 ]; then
              AFFECTED_SERVICES="[$(IFS=,; echo "${AFFECTED[*]}")]"
              SHOULD_DEPLOY=true
            else
              AFFECTED_SERVICES='[]'
              # Still deploy if infra or DB changed
              if [ "$HAS_INFRA_CHANGES" = "true" ] || [ "$HAS_DB_CHANGES" = "true" ]; then
                SHOULD_DEPLOY=true
              else
                SHOULD_DEPLOY=false
              fi
            fi
          fi
          
          echo "services=$AFFECTED_SERVICES" >> "$GITHUB_OUTPUT"
          echo "has_infra_changes=$HAS_INFRA_CHANGES" >> "$GITHUB_OUTPUT"
          echo "has_db_changes=$HAS_DB_CHANGES" >> "$GITHUB_OUTPUT"
          echo "should_deploy=$SHOULD_DEPLOY" >> "$GITHUB_OUTPUT"
          
          echo "Affected services: $AFFECTED_SERVICES"
          echo "Has infrastructure changes: $HAS_INFRA_CHANGES"
          echo "Has database changes: $HAS_DB_CHANGES"
          echo "Should deploy: $SHOULD_DEPLOY"

  deploy-infrastructure:
    name: Deploy infrastructure
    needs: detect-changes
    if: needs.detect-changes.outputs.should_deploy == 'true' && needs.detect-changes.outputs.has_infra_changes == 'true'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    env:
      BUILD_VERSION: ${{ needs.detect-changes.outputs.build_version }}
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Prepare Terraform plugin cache
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-terraform-${{ hashFiles('infra/terraform/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Fetch database password
        id: db-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Prepare Terraform configuration
        env:
          DB_PASSWORD: ${{ steps.db-secret.outputs.db_password }}
        run: |
          echo "::add-mask::${DB_PASSWORD}"
          
          # Prepare backend config
          cat > infra/terraform/backend.hcl <<EOF
          bucket = "${{ env.TF_BACKEND_BUCKET }}"
          prefix = "${{ env.TF_BACKEND_PREFIX }}"
          EOF
          
          # Prepare tfvars
          if [ ! -f infra/terraform/terraform.tfvars ]; then
            cp infra/terraform/terraform.tfvars.example infra/terraform/terraform.tfvars
          fi
          
          # Update db_password in tfvars
          grep -v '^[[:space:]]*db_password[[:space:]]*=' infra/terraform/terraform.tfvars > /tmp/tfvars || true
          echo "db_password = \"${DB_PASSWORD}\"" >> /tmp/tfvars
          mv /tmp/tfvars infra/terraform/terraform.tfvars

      - name: Terraform init
        working-directory: infra/terraform
        run: terraform init -input=false -backend-config=backend.hcl

      - name: Terraform validate
        working-directory: infra/terraform
        run: terraform validate

      - name: Terraform plan
        working-directory: infra/terraform
        run: |
          terraform plan \
            -input=false \
            -var=project_id="${{ env.GCP_PROJECT_ID }}" \
            -var=region="${{ env.GCP_REGION }}" \
            -var=image_version="${{ env.BUILD_VERSION }}" \
            -out=tfplan

      - name: Terraform apply
        working-directory: infra/terraform
        run: terraform apply -input=false -auto-approve tfplan

  build-and-push:
    name: Build and push ${{ matrix.service }}
    needs: 
      - detect-changes
      - deploy-infrastructure
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      contains(fromJson(needs.detect-changes.outputs.affected_services), matrix.service) &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.affected_services) }}
    env:
      BUILD_VERSION: ${{ needs.detect-changes.outputs.build_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Restore Turborepo cache
        uses: actions/cache@v4
        with:
          path: |
            .turbo
            node_modules/.cache/turbo
          key: ${{ runner.os }}-turbo-${{ matrix.service }}-${{ hashFiles('**/package.json', 'yarn.lock', 'turbo.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-${{ matrix.service }}-${{ hashFiles('**/package.json', 'yarn.lock', 'turbo.json') }}-
            ${{ runner.os }}-turbo-${{ matrix.service }}-

      - name: Generate Prisma client
        run: yarn --cwd libs/database generate

      - name: Run GraphQL codegen
        if: matrix.service == 'dm' || matrix.service == 'slack-bot'
        run: yarn turbo codegen --filter=@mud/${{ matrix.service }}

      - name: Build service
        run: yarn turbo build --filter=@mud/${{ matrix.service }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Docker authentication
        run: gcloud auth configure-docker "${{ env.GCP_REGION }}-docker.pkg.dev" --quiet

      - name: Build and push Docker image
        run: |
          REGISTRY_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.REGISTRY_NAME }}"
          IMAGE_TAG="${REGISTRY_URL}/${{ matrix.service }}:${{ env.BUILD_VERSION }}"
          IMAGE_LATEST="${REGISTRY_URL}/${{ matrix.service }}:latest"
          
          echo "Building image for ${{ matrix.service }}..."
          docker build \
            -t "$IMAGE_TAG" \
            -t "$IMAGE_LATEST" \
            -f "apps/${{ matrix.service }}/Dockerfile" \
            .
          
          echo "Pushing images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"
          
          echo "✅ Successfully pushed ${{ matrix.service }} images"

  deploy-services:
    name: Deploy ${{ matrix.service }} to Cloud Run
    needs:
      - detect-changes
      - build-and-push
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      contains(fromJson(needs.detect-changes.outputs.affected_services), matrix.service) &&
      needs.build-and-push.result == 'success'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.affected_services) }}
    env:
      BUILD_VERSION: ${{ needs.detect-changes.outputs.build_version }}
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Deploy to Cloud Run
        run: |
          REGISTRY_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.REGISTRY_NAME }}"
          IMAGE="${REGISTRY_URL}/${{ matrix.service }}:${{ env.BUILD_VERSION }}"
          
          echo "Deploying ${{ matrix.service }} to Cloud Run..."
          gcloud run services update "mud-${{ matrix.service }}" \
            --region="${{ env.GCP_REGION }}" \
            --image="$IMAGE" \
            --quiet
          
          echo "✅ Successfully deployed ${{ matrix.service }}"

  run-migrations:
    name: Run database migrations
    needs:
      - detect-changes
      - deploy-infrastructure
      - build-and-push
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      needs.detect-changes.outputs.has_db_changes == 'true' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Fetch database password
        id: db-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Install Cloud SQL Proxy
        run: |
          curl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.18.1/cloud-sql-proxy.linux.amd64
          chmod +x cloud-sql-proxy

      - name: Run Prisma migrations
        env:
          DB_PASSWORD: ${{ steps.db-secret.outputs.db_password }}
        run: |
          echo "::add-mask::${DB_PASSWORD}"
          
          # Start Cloud SQL Proxy
          ./cloud-sql-proxy --address=127.0.0.1 --port=5432 "${{ env.CLOUD_SQL_CONNECTION_NAME }}" &
          PROXY_PID=$!
          
          # Wait for proxy to be ready
          sleep 5
          
          # Run migrations
          export DATABASE_URL="postgresql://mud:${DB_PASSWORD}@127.0.0.1:5432/mud_dev?schema=public&sslmode=disable&connect_timeout=60"
          npx prisma migrate deploy --schema=libs/database/prisma/schema.prisma
          
          # Cleanup
          kill $PROXY_PID || true
          
          echo "✅ Database migrations completed"

  update-service-endpoints:
    name: Update service endpoints
    needs:
      - detect-changes
      - deploy-services
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      needs.deploy-services.result == 'success'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Update service environment variables
        run: |
          # Get service URLs
          DM_URL=$(gcloud run services describe mud-dm --region "${{ env.GCP_REGION }}" --format="value(status.url)" 2>/dev/null || echo "")
          WORLD_URL=$(gcloud run services describe mud-world --region "${{ env.GCP_REGION }}" --format="value(status.url)" 2>/dev/null || echo "")
          
          if [ -z "$DM_URL" ] || [ -z "$WORLD_URL" ]; then
            echo "⚠️  Could not retrieve service URLs, skipping endpoint update"
            exit 0
          fi
          
          DM_GQL="${DM_URL}/graphql"
          WORLD_GQL="${WORLD_URL}/graphql"
          WORLD_BASE="${WORLD_URL}/world"
          
          echo "Service endpoints:"
          echo "  DM_GQL_ENDPOINT=$DM_GQL"
          echo "  WORLD_GQL_ENDPOINT=$WORLD_GQL"
          echo "  WORLD_BASE_URL=$WORLD_BASE"
          
          # Update slack-bot
          if gcloud run services describe mud-slack-bot --region "${{ env.GCP_REGION }}" >/dev/null 2>&1; then
            gcloud run services update mud-slack-bot \
              --region="${{ env.GCP_REGION }}" \
              --update-env-vars="DM_GQL_ENDPOINT=${DM_GQL},WORLD_GQL_ENDPOINT=${WORLD_GQL},WORLD_BASE_URL=${WORLD_BASE}" \
              --quiet
            echo "✅ Updated slack-bot endpoints"
          fi
          
          # Update tick
          if gcloud run services describe mud-tick --region "${{ env.GCP_REGION }}" >/dev/null 2>&1; then
            gcloud run services update mud-tick \
              --region="${{ env.GCP_REGION }}" \
              --update-env-vars="DM_GRAPHQL_URL=${DM_GQL}" \
              --quiet
            echo "✅ Updated tick endpoints"
          fi
    name: Build and Push Images
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
      id-token: write
    outputs:
      build_version: ${{ steps.version.outputs.build_version }}
      services: ${{ steps.affected.outputs.services_csv }}
      services_json: ${{ steps.affected.outputs.services_json }}
      services_matrix: ${{ steps.affected.outputs.services_matrix }}
      has_service_changes: ${{ steps.affected.outputs.has_service_changes }}
      infra_changed: ${{ steps.affected.outputs.infra_changed }}
      should_deploy: ${{ steps.affected.outputs.should_deploy }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine build version
        id: version
        run: |
          set -eo pipefail
          VERSION_INPUT="${{ inputs.build_version }}"
          if [ -n "$VERSION_INPUT" ]; then
            VERSION="$VERSION_INPUT"
          else
            if git rev-parse --short HEAD >/tmp/short_sha 2>/dev/null; then
              VERSION=$(cat /tmp/short_sha)
            else
              VERSION=$(date -u +"%Y%m%d%H%M%S")
            fi
          fi
          echo "Using build version: $VERSION"
          echo "BUILD_VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "build_version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Restore Turborepo cache
        uses: actions/cache@v4
        with:
          path: |
            .turbo
            node_modules/.cache/turbo
          key: ${{ runner.os }}-turbo-${{ hashFiles('**/package.json', 'yarn.lock', 'turbo.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-${{ hashFiles('**/package.json', 'yarn.lock', 'turbo.json') }}-
            ${{ runner.os }}-turbo-

      - name: Determine affected deployment scope
        id: affected
        env:
          EVENT_NAME: ${{ github.event_name }}
          BEFORE_SHA: ${{ github.event.before }}
        run: |
          set -Eeuo pipefail
          ALL_SERVICES=(dm world slack-bot tick)
          FORCE_ALL=0
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            FORCE_ALL=1
          fi

          BASE_SHA="$BEFORE_SHA"
          HEAD_SHA="${GITHUB_SHA}"
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ]; then
            if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
              BASE_SHA=$(git rev-parse HEAD^)
            else
              BASE_SHA=$HEAD_SHA
            fi
          fi
          echo "Comparing changes between $BASE_SHA and $HEAD_SHA"

          INFRA_CHANGED=0
          if git diff --name-only "$BASE_SHA" "$HEAD_SHA" | grep '^infra/terraform/' >/dev/null; then
            INFRA_CHANGED=1
            echo "Detected infrastructure changes under infra/terraform/."
          fi

          SERVICES=()
          declare -A seen=()

          if [ $FORCE_ALL -eq 1 ]; then
            echo "workflow_dispatch event detected; deploying all services."
            SERVICES=("${ALL_SERVICES[@]}")
          else
            declare -A package_map=(
              [dm]="@mud/dm"
              [world]="@mud/world"
              [slack-bot]="@mud/slack-bot"
              [tick]="@mud/tick"
            )

            TURBO_BIN="./node_modules/.bin/turbo"
            if [ ! -x "$TURBO_BIN" ]; then
              TURBO_BIN=""
            fi

            run_turbo() {
              if [ -n "$TURBO_BIN" ]; then
                "$TURBO_BIN" "$@"
              else
                npx --yes turbo "$@"
              fi
            }

            TURBO_FAILURE=0
            for svc in "${ALL_SERVICES[@]}"; do
              pkg="${package_map[$svc]}"
              tmp_json=$(mktemp)
              tmp_err=$(mktemp)
              if run_turbo run build "--filter=${pkg}...[${BASE_SHA}]" --dry-run=json >"$tmp_json" 2>"$tmp_err"; then
                task_count=$(jq '.tasks | length' "$tmp_json")
                if [ "$task_count" -gt 0 ] && [ -z "${seen[$svc]:-}" ]; then
                  SERVICES+=("$svc")
                  seen[$svc]=1
                fi
              else
                echo "Failed to evaluate turborepo changes for ${svc}."
                cat "$tmp_err" || true
                TURBO_FAILURE=1
                rm -f "$tmp_json" "$tmp_err"
                break
              fi
              rm -f "$tmp_json" "$tmp_err"
            done

            if [ $TURBO_FAILURE -eq 1 ]; then
              echo "turborepo change detection failed; defaulting to all services."
              SERVICES=("${ALL_SERVICES[@]}")
            fi
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            IFS=$'\n' SERVICES=($(printf '%s\n' "${SERVICES[@]}" | sort))
          fi

          SERVICES_JSON="[]"
          SERVICES_MATRIX='[{"service":"__noop__","skip":true}]'
          if [ ${#SERVICES[@]} -gt 0 ]; then
            json_items=()
            matrix_items=()
            for svc in "${SERVICES[@]}"; do
              json_items+=("\"${svc}\"")
              matrix_items+=("{\"service\":\"${svc}\",\"skip\":false}")
            done
            SERVICES_JSON="[$(IFS=,; echo "${json_items[*]}")]"
            SERVICES_MATRIX="[$(IFS=,; echo "${matrix_items[*]}")]"
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            HAS_SERVICE_CHANGES=true
            echo "Affected services: ${SERVICES[*]}"
          else
            HAS_SERVICE_CHANGES=false
            echo "No Turborepo-affected services detected."
          fi

          if [ $INFRA_CHANGED -eq 1 ]; then
            echo "Infrastructure changes detected."
          fi

          if [ "$HAS_SERVICE_CHANGES" = "true" ] || [ $INFRA_CHANGED -eq 1 ] || [ $FORCE_ALL -eq 1 ]; then
            SHOULD_DEPLOY=true
          else
            SHOULD_DEPLOY=false
          fi

          if [ "$SHOULD_DEPLOY" = "false" ]; then
            echo "No deployable changes detected; subsequent deployment steps will be skipped."
          fi

          if [ ${#SERVICES[@]} -gt 0 ]; then
            SERVICES_CSV=$(IFS=,; echo "${SERVICES[*]}")
          else
            SERVICES_CSV=""
          fi

          {
            echo "services_csv=$SERVICES_CSV"
            echo "services_json=$SERVICES_JSON"
            echo "services_matrix=$SERVICES_MATRIX"
            echo "has_service_changes=$HAS_SERVICE_CHANGES"
            echo "infra_changed=$([ $INFRA_CHANGED -eq 1 ] && echo true || echo false)"
            echo "should_deploy=$SHOULD_DEPLOY"
          } >>"$GITHUB_OUTPUT"

      - name: Ensure Workload Identity secrets are configured
        if: steps.affected.outputs.has_service_changes == 'true'
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        if: steps.affected.outputs.has_service_changes == 'true'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        if: steps.affected.outputs.has_service_changes == 'true'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        if: steps.affected.outputs.has_service_changes == 'true'
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Configure Docker authentication
        if: steps.affected.outputs.has_service_changes == 'true'
        run: gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

  build-service:
    name: Build and Push Service (${{ matrix.service }})
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.build-and-push.outputs.services_matrix) }}
    env:
      BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Skip noop matrix entry
        if: ${{ matrix.skip == true }}
        run: echo "No services to build for this matrix entry."

      - name: Authenticate to Google Cloud
        if: ${{ matrix.skip != true }}
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        if: ${{ matrix.skip != true }}
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        if: ${{ matrix.skip != true }}
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Configure Docker authentication
        if: ${{ matrix.skip != true }}
        run: gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

      - name: Build and push service image
        if: ${{ matrix.skip != true }}
        env:
          SERVICE_NAME: ${{ matrix.service }}
        run: |
          set -Eeuo pipefail
          REGISTRY_URL="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REGISTRY_NAME}"
          IMAGE_TAG="${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_VERSION}"
          IMAGE_LATEST="${REGISTRY_URL}/${SERVICE_NAME}:latest"
          DOCKERFILE="apps/${SERVICE_NAME}/Dockerfile"
          echo "Building image for ${SERVICE_NAME}..."
          docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" -f "$DOCKERFILE" .
          echo "Pushing ${SERVICE_NAME} images..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"

  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs:
      - build-and-push
      - build-service
    if: needs.build-and-push.outputs.should_deploy == 'true'
    environment: production
    permissions:
      contents: read
      id-token: write
    env:
      BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure Workload Identity secrets are configured
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Prepare Terraform plugin cache directory
        run: mkdir -p "$TF_PLUGIN_CACHE_DIR"

      - name: Cache Terraform plugin directory
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-terraform-${{ hashFiles('infra/terraform/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Ensure terraform.tfvars exists
        run: |
          if [ ! -f infra/terraform/terraform.tfvars ]; then
            cp infra/terraform/terraform.tfvars.example infra/terraform/terraform.tfvars
            terraform fmt -recursive infra/terraform/terraform.tfvars
          fi

      - name: Fetch database password secret
        id: db-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Inject database password into Terraform vars
        env:
          DB_PASSWORD: ${{ steps.db-secret.outputs.db_password }}
        run: |
          set -Eeuo pipefail
          echo "::add-mask::${DB_PASSWORD}"
          TFVARS="infra/terraform/terraform.tfvars"
          TMP_FILE="$(mktemp)"
          if [ -f "$TFVARS" ]; then
            grep -v '^[[:space:]]*db_password[[:space:]]*=' "$TFVARS" > "$TMP_FILE"
          fi
          printf 'db_password = "%s"\n' "$DB_PASSWORD" >> "$TMP_FILE"
          install -m 0644 "$TMP_FILE" "$TFVARS"
          rm -f "$TMP_FILE"

      - name: Prepare service image overrides
        env:
          BUILD_VERSION: ${{ needs.build-and-push.outputs.build_version }}
          SERVICES_CSV: ${{ needs.build-and-push.outputs.services }}
        run: |
          set -Eeuo pipefail
          REGISTRY_URL="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${REGISTRY_NAME}"
          declare -A changed=()
          if [ -n "$SERVICES_CSV" ]; then
            IFS=',' read -ra CHANGED <<< "$SERVICES_CSV"
            for svc in "${CHANGED[@]}"; do
              [ -n "$svc" ] || continue
              changed[$svc]=1
            done
          fi

          SERVICES=(dm world slack-bot tick)
          TF_FILE="infra/terraform/service-overrides.auto.tfvars"
          {
            echo "service_image_overrides = {"
            for svc in "${SERVICES[@]}"; do
              if [ -n "${changed[$svc]:-}" ]; then
                image="${REGISTRY_URL}/${svc}:${BUILD_VERSION}"
              else
                image=$(gcloud run services describe "mud-${svc}" --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(template.containers[0].image)" || true)
                if [ -z "$image" ]; then
                  image="${REGISTRY_URL}/${svc}:latest"
                fi
              fi
              echo "  \"${svc}\" = \"${image}\""
            done
            echo "}"
          } > "$TF_FILE"
          terraform -chdir=infra/terraform fmt "$(basename "$TF_FILE")"
          echo "Pinned service images written to $TF_FILE"

      - name: Write Terraform backend config
        env:
          TF_BACKEND_BUCKET: ${{ env.TF_BACKEND_BUCKET }}
          TF_BACKEND_PREFIX: ${{ env.TF_BACKEND_PREFIX }}
        run: |
          set -Eeuo pipefail
          if [ -z "$TF_BACKEND_BUCKET" ] || [ -z "$TF_BACKEND_PREFIX" ]; then
            echo "Missing TF_BACKEND_BUCKET or TF_BACKEND_PREFIX secrets."
            exit 1
          fi
          printf 'bucket = "%s"\n' "$TF_BACKEND_BUCKET" > infra/terraform/backend.hcl
          printf 'prefix = "%s"\n' "$TF_BACKEND_PREFIX" >> infra/terraform/backend.hcl
          echo "Terraform backend config written to infra/terraform/backend.hcl"

      - name: Terraform fmt check
        working-directory: infra/terraform
        run: terraform fmt -check -recursive

      - name: Terraform init
        working-directory: infra/terraform
        run: terraform init -input=false -backend-config=backend.hcl

      - name: Terraform validate
        working-directory: infra/terraform
        run: terraform validate

      - name: Terraform plan
        working-directory: infra/terraform
        run: |
          terraform plan \
            -input=false \
            -var=project_id="$GCP_PROJECT_ID" \
            -var=region="$GCP_REGION" \
            -var=image_version="$BUILD_VERSION" \
            -out=tfplan

      - name: Terraform apply
        working-directory: infra/terraform
        run: |
          terraform apply \
            -input=false \
            -auto-approve \
            tfplan

      - name: Clean up Terraform plan
        if: always()
        working-directory: infra/terraform
        run: rm -f tfplan

      - name: Clean up service image overrides
        if: always()
        run: rm -f infra/terraform/service-overrides.auto.tfvars

      - name: Update service endpoints
        run: |
          set -Eeuo pipefail
          DM_URL=$(gcloud run services describe mud-dm --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(status.url)")
          WORLD_URL=$(gcloud run services describe mud-world --region "$GCP_REGION" --project "$GCP_PROJECT_ID" --format="value(status.url)")
          if [ -z "$DM_URL" ] || [ -z "$WORLD_URL" ]; then
            echo "Could not retrieve dm/world service URLs. Skipping endpoint update."
            exit 0
          fi
          DM_GQL="${DM_URL}/graphql"
          WORLD_GQL="${WORLD_URL}/graphql"
          WORLD_BASE="${WORLD_URL}/world"
          echo "Resolved endpoints:"
          echo "  DM_GQL_ENDPOINT=$DM_GQL"
          echo "  WORLD_GQL_ENDPOINT=$WORLD_GQL"
          echo "  WORLD_BASE_URL=$WORLD_BASE"
          gcloud run services update mud-slack-bot \
            --region="$GCP_REGION" \
            --project="$GCP_PROJECT_ID" \
            --update-env-vars="DM_GQL_ENDPOINT=${DM_GQL},WORLD_GQL_ENDPOINT=${WORLD_GQL}"
          gcloud run services update mud-tick \
            --region="$GCP_REGION" \
            --project="$GCP_PROJECT_ID" \
            --update-env-vars="DM_GRAPHQL_URL=${DM_GQL}"

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs:
      - deploy-infra
    environment: production
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Ensure Workload Identity secrets are configured
        env:
          WORKLOAD_IDENTITY_PROVIDER: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ env.GCP_SERVICE_ACCOUNT }}
        run: |
          set -Eeuo pipefail
          if [ -z "$WORKLOAD_IDENTITY_PROVIDER" ] || [ -z "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" ]; then
            echo "Missing workload identity federation secrets."
            echo "Set both GCP_WORKLOAD_IDENTITY_PROVIDER and GCP_SERVICE_ACCOUNT secrets."
            exit 1
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure gcloud defaults
        run: |
          gcloud config set project "$GCP_PROJECT_ID"
          gcloud config set compute/region "$GCP_REGION"

      - name: Fetch database password secret
        id: migration-secret
        uses: google-github-actions/get-secretmanager-secrets@v1
        with:
          secrets: |
            db_password:projects/${{ env.GCP_PROJECT_ID }}/secrets/cloud-sql-db-password/versions/latest

      - name: Run Prisma migrations
        env:
          DB_PASSWORD: ${{ steps.migration-secret.outputs.db_password }}
        run: |
          set -Eeuo pipefail
          echo "::add-mask::${DB_PASSWORD}"
          CONNECTION_NAME="${CLOUD_SQL_CONNECTION_NAME:-battleforge-444008:us-central1:mud-postgres}"
          PROXY_PATH="scripts/cloud-sql-proxy"
          if [ ! -f "$PROXY_PATH" ]; then
            curl -sSL -o "$PROXY_PATH" "https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.18.1/cloud-sql-proxy.linux.amd64"
            chmod +x "$PROXY_PATH"
          fi
          "$PROXY_PATH" --address=127.0.0.1 --port=5432 "$CONNECTION_NAME" &
          PROXY_PID=$!
          cleanup() {
            if kill -0 "$PROXY_PID" 2>/dev/null; then
              kill "$PROXY_PID"
              wait "$PROXY_PID" || true
            fi
          }
          trap cleanup EXIT
          sleep 5
          export DATABASE_URL="postgresql://mud:${DB_PASSWORD}@127.0.0.1:5432/mud_dev?schema=public&sslmode=disable&connect_timeout=60"
          npx prisma migrate deploy --schema=libs/database/prisma/schema.prisma
